generator client {
  provider = "prisma-client-js"
}

generator json {
  provider = "prisma-json-types-generator"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                String          @id @default(cuid())
  email             String          @unique
  googleId          String?         @unique
  facebookId        String?         @unique
  status            UserStatus      @default(PENDING)
  profilePicture    String?
  fullname          String
  password          String?
  telephone         String?
  accountType       AccountType     @default(BUYER)
  orders            Order[]
  myRatings         Rating[]
  store             Store?          @relation(name: "myPersonalStore")
  favouriteStores   Store[]         @relation(name: "myFavouriteStores")
  favouriteProducts Product[]
  verifyUser        verifyUser?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  sellerMessage     sellerMessage[]
  address           Address?
  viewedProducts    ViewsTracker[]

  @@map("users")
}

model Store {
  id                      String                    @id @default(cuid())
  name                    String                    @unique
  description             String                    @db.VarChar(255)
  image                   String?
  location                String
  userId                  String                    @unique
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  products                Product[]
  user                    User                      @relation(fields: [userId], references: [id], onDelete: Cascade, name: "myPersonalStore")
  favourite               User[]                    @relation(name: "myFavouriteStores")
  sellerDashboard         SellerDashboard?
  sellerPaymentHistory    SellerPaymentHistory[]
  sellerWithdrawalHistory SellerWithdrawalHistory[]
  shippingFee             Float                     @default(2.99)
  sellerMessage           sellerMessage[]
  bankDetails             BankDetails?
  orderDetails            OrderDetails[]

  @@map("store")
}

model Product {
  id                 String          @id @default(cuid())
  name               String
  itemCondition      ItemContitions
  salesType          SalesType       @default(ONCE)
  endBiddingDate     DateTime?
  amount             Float           @default(0)
  quantity           Int             @default(0)
  details            String          @db.VarChar(255)
  publish            Boolean         @default(true)
  coverImage         String
  /// [productImages]
  images             Json?           @default("[]")
  returnPolicy       String?
  location           String?
  storeId            String
  discount           Boolean         @default(false)
  discountPercentage Float           @default(0)
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  store              Store           @relation(fields: [storeId], references: [id], onDelete: Cascade)
  categories         Category[]
  favourite          User[]
  orderDetails       OrderDetails[]
  deleted            Boolean         @default(false)
  views              ViewsTracker[]
  sellerMessage      sellerMessage[]

  @@unique([storeId, name])
  @@map("products")
}

model Category {
  id        String    @id @default(cuid())
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  products  Product[]

  @@map("categories")
}

model Order {
  id                   String                 @id @default(cuid())
  orderId              Int                    @unique
  amount               Float
  userId               String?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  user                 User?                  @relation(fields: [userId], references: [id])
  transactionId        String?
  paymentStatus        Boolean                @default(false)
  datePaid             DateTime?
  sellerPaymentHistory SellerPaymentHistory[]
  orderDetails         OrderDetails[]

  @@map("orders")
}

model OrderDetails {
  id          String      @id @default(uuid())
  amount      Float
  quantity    Int
  status      OrderStatus @default(PENDING)
  order       Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId     String
  product     Product     @relation(fields: [productId], references: [id])
  productId   String
  shippingFee Float
  interest    Float
  store       Store       @relation(fields: [storeId], references: [id])
  storeId     String
  updatedAt   DateTime    @updatedAt
  createdAt   DateTime    @default(now())
  review      Rating?

  @@unique([orderId, productId])
  @@map("orderdetails")
}

model ViewsTracker {
  id        String   @id @default(uuid())
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  ipAddress String?
  viewedAt  DateTime @updatedAt
  createdAt DateTime @default(now())

  @@unique([userId, productId])
  @@unique([ipAddress, productId])
  @@map("productviews")
}

model Rating {
  id             String       @id @default(uuid())
  rating         Int
  review         String
  userId         String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User         @relation(fields: [userId], references: [id], onDelete: NoAction)
  orderDetails   OrderDetails @relation(fields: [orderDetailsId], references: [id], onDelete: Cascade)
  orderDetailsId String       @unique

  @@map("ratings")
}

model SellerDashboard {
  id         String                    @id @default(uuid())
  amount     Float                     @default(0)
  updatedAt  DateTime                  @updatedAt
  createdAt  DateTime                  @default(now())
  store      Store                     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  storeId    String                    @unique
  withdrawal SellerWithdrawalHistory[]
  payment    SellerPaymentHistory[]

  @@map("sellersdashboard")
}

model SellerPaymentHistory {
  id                String           @id @default(uuid())
  amount            Float            @default(0)
  updatedAt         DateTime         @updatedAt
  createdAt         DateTime         @default(now())
  store             Store            @relation(fields: [storeId], references: [id], onDelete: Cascade)
  storeId           String
  order             Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId           String
  sellerDashboard   SellerDashboard? @relation(fields: [sellerDashboardId], references: [id])
  sellerDashboardId String?

  @@unique([storeId, orderId])
  @@map("sellerspaymenthistory")
}

model SellerWithdrawalHistory {
  id                String           @id @default(uuid())
  amount            Float            @default(0)
  store             Store            @relation(fields: [storeId], references: [id], onDelete: Cascade)
  storeId           String
  sellerDashboard   SellerDashboard? @relation(fields: [sellerDashboardId], references: [id])
  sellerDashboardId String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@map("sellerswithdrawalhistory")
}

model Sessions {
  session_id String @id @db.VarChar(128)
  expires    Int
  data       String @db.MediumText

  @@map("sessions")
}

model sellerMessage {
  id        String       @id @unique @default(cuid())
  from      MessagesFrom @default(USER)
  store     Store        @relation(fields: [storeId], references: [id])
  storeId   String
  user      User?        @relation(fields: [userId], references: [id])
  userId    String?
  message   String
  product   Product?     @relation(fields: [productId], references: [id])
  productId String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@map("sellermessage")
}

model Settings {
  id            String   @id @unique @default(cuid())
  profitPercent Float    @default(10)
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())

  @@map("settings")
}

model BankDetails {
  id            String   @unique @default(cuid())
  store         Store    @relation(fields: [storeId], references: [id])
  storeId       String   @unique
  accountNumber String
  bank          String
  nameOnAccount String?
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())

  @@unique([storeId, accountNumber, nameOnAccount])
  @@map("bankdetails")
}

model Address {
  id          String   @unique @default(cuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String   @unique
  houseNumber String?
  street      String?
  postCode    String?
  city        String
  country     String   @default("United Kingdom")
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  @@map("addresses")
}

model verifyUser {
  id        String   @id @default(cuid())
  userId    String   @unique(map: "VerifyUser_userId_key")
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Engagement {
  id          Int      @id @default(autoincrement())
  date        DateTime
  dailyUsers  Int
  interactions Int
}

model HashtagRanking {
  id         Int      @id @default(autoincrement())
  hashtag    String
  frequency  Int
}


model MarketingActivity {
  id            Int      @id @default(autoincrement())
  type          String
  clicks        Int
  impressions   Int
  conversions   Int
  costPerClick  Float
  openRate      Float?
  clickRate     Float?
  date          DateTime
}

enum UserStatus {
  VERIFIED
  PENDING
  FAILED
}

enum OrderStatus {
  PENDING
  DISPATCHED
  DELIVERED
}

enum MessagesFrom {
  USER
  ADMIN
}

enum AccountType {
  BUYER
  SELLER
  ADMIN
}

enum TrackerStatus {
  PENDING
  DELAYED
  CANCELLED
  PAUSED
}

enum ItemContitions {
  NEW
  USED
  REFURBISHED
}

enum SalesType {
  BIDDING
  ONCE
}
